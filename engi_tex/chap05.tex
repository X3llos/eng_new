\chapter{Implementacja systemu kolizji z wykorzystaniem OpenCL}

\section{Inicjalizacja OpenCL}
W części inicjalizującej odczytany zostaje plik kernela. Został on podzielony na cztery głowne sekcje - strukturę obietków, stałe, dodatkowe funkcje oraz samą funkcję kernela.

\subsection{Struktura obiektów}
W tej części zdefiniowana została struktura odzwierciedlająca dane, jakie posiadają obiekty użyte w symulacji. Aby dane przekazane z pamięci RAM do pamięci GPU mogły zostać poprawnie odczytane, kolejność definiowanych składowych obiektu musi być identyczna z kolejnością zdefiniowaną w części programu hosta.

\subsection{Stałe}
Ta część zawiera dane stałe, wykorzystywane przez funkcje pomocnicze. Zdefiniowane tu zostały takie dane jak wartość grawitacji czy opór powietrza.

\subsection{Funkcje pomocnicze}
Dzięki wzorowaniu się na standardzie C99 OpenCL pozwala na wykorzystanie funkcji. Umożliwia to znaczne zwiększenie czytelności oprogramowania oraz szybsze wprowadzenie ewentualnych zmian. W celu przyspieszenia wykonywania kernela argumenty funkcji są przekazywane przez wskaźnik, co niweluje konieczność tworzenia obiektów tymczasowych, a co za tym idzie dodatkowego czasu na alokowanie oraz zwalnianie duzych obszarów pamięci.

\subsection{Kernel}
Funkcja kernela na samym początku pobiera identyfikator: \\
unsigned int i \= get\_global\_id(0); \\
Funkcja ta pobiera globalny identyfukator wątku. W przypadku stworzonej symulacji, operacje dla każdej bryły sztywnej biorącej udział w symulacji wykonywane są na oddzielnym wątku. Dzięki temu, identyfikator określa również daną bryłę, na której wykonujemy operacje. Samo odwołanie do elementów, na któych wykonywane są operacje przypomina odwołanie się do kolejnych elementów w tabeli. \\
Sam proces inicjalizacyjny ropoczynany jest od pobrania platform. W przypadku użytych urządzeń zostaną wykryte dwie plaftormy: karta NVIDIA GeForce GTX 760 oraz procesor Intel\textregistered Core\texttrademark i5-3570K. \\ Następnie utworzony zostaje kontekst obliczeniowy oraz tworzona jest kolejka zadań. Kolejka służy jako interfejs do wysyłania do urządzenia zadań (tj. kopia danych do/z platformy, wysłanie kernela). \\
Kolejnym krokiem jest utworzenie obiektu programu, w którym używamy wcześniej stworzonego pliku kernela. Plik przekazywany jest z użyciem typu char*, zatem należy uprzednio wczytać plik do pamięci. \\
Po wykonaniu tych operacji należy zbudować program, używając stworzonego obiektu programu. Program budowany jest dla określonego urządzenia lub jeśli jako argument została podana wartość NULL, program jest budowany na wszystkich znalezionych urządzeniach. \\
Po zbudowaniu mozemy stworzyć obiekt kernela z programu. Jako argument podajemy nazwę funkcji z uzytego pliku kernela. Stworzony obiekt kernela będzie można wysłać, po ustaleniu parametrów, za pomocą kolejki zadań do wykonania. \\
Następnie należy utworzyć zmienne typu cl\_mem, które będą służyły jako bufory wejścia/wyjścia w pamięci urządzenia. Każda zmienna tego typu może zostać oznaczona jako tylko do odczytu (CL\_MEM\_READ\_ONLY), tylko do zapisu (CL\_MEM\_WRITE\_ONLY) oraz z pełnym dostępem ( CL\_MEM\_READ\_WRITE). \\
Po utworzeniu danych należy przetransferować dane z pamięci hosta do pamięci urządzenia, gdyż kernel nie posiada bezpośredniego dostępu do danych umieszczonych w pamięci hosta. \\
Jako, że kernel zostanie wysłany do kolejki zadań, należy odpowiednio ustawić parametry będące argumentami dla przesyłanej funkcji kernela. \\
Gdy wszystkie etapy zostały wykonane, można przesłać obiekt kernela do kolejki zadań. \\
Następnie należy zaczekać na zakończenie obliczeń przez urządzenie. Jeśli ten krok zostanie pominięty a urządzenie nie skończy wykonywać kodu kernela, nasze dane wyjściowe będą niepełne oraz błędne. \\
Gdy kernel zakończy prawidłowo pracę, należy przekopiować wynik z pamięci urządzenia do pamięci hosta. \\
Gdy dane zostaną przekopiowane, należy usunąć zainicjowane wcześniej obiekty OpenCL. \\

\section{Przekazywanie danych pomiędzy pamięcią RAM a pamięcią GPU}
Obiekty symulacji przekazywane jako argument do funkcji kernela, które będą uzywane przez wszystkie wątki, należy zaalokować do pamięci globalnej. Używana jest do tego dyrektywa  \begin{verbatim}__global\end{verbatim}. 
